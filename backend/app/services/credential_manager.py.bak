import os
import json
import base64
from cryptography.fernet import Fernet
from typing import Dict, Any, Optional
from sqlalchemy.orm import Session
from app.models.workflow import UserCredential

class CredentialManager:
    """
    Gestionnaire sécurisé des credentials utilisateur pour les intégrations.
    """
    
    def __init__(self):
        # Clé de chiffrement depuis les variables d'environnement
        encryption_key = os.getenv("CREDENTIAL_ENCRYPTION_KEY")
        if not encryption_key:
            # Générer une clé pour le développement (à ne pas faire en production)
            encryption_key = Fernet.generate_key().decode()
            print(f"⚠️  Generated encryption key: {encryption_key}")
            print("⚠️  Set CREDENTIAL_ENCRYPTION_KEY environment variable in production!")
        
        self.cipher = Fernet(encryption_key.encode() if isinstance(encryption_key, str) else encryption_key)

    def encrypt_credentials(self, credentials: Dict[str, Any]) -> str:
        """Chiffre les credentials utilisateur."""
        credentials_json = json.dumps(credentials)
        encrypted_data = self.cipher.encrypt(credentials_json.encode())
        return base64.b64encode(encrypted_data).decode()

    def decrypt_credentials(self, encrypted_credentials: str) -> Dict[str, Any]:
        """Déchiffre les credentials utilisateur."""
        try:
            encrypted_data = base64.b64decode(encrypted_credentials.encode())
            decrypted_data = self.cipher.decrypt(encrypted_data)
            return json.loads(decrypted_data.decode())
        except Exception as e:
            raise ValueError(f"Failed to decrypt credentials: {e}")

    def store_user_credentials(self, 
                             db: Session, 
                             user_id: int, 
                             service_name: str, 
                             credential_type: str,
                             credentials: Dict[str, Any]) -> UserCredential:
        """
        Stocke les credentials utilisateur de manière sécurisée.
        """
        # Vérifier si des credentials existent déjà
        existing = db.query(UserCredential).filter(
            UserCredential.user_id == user_id,
            UserCredential.service_name == service_name
        ).first()

        encrypted_creds = self.encrypt_credentials(credentials)

        if existing:
            # Mettre à jour
            existing.encrypted_credentials = encrypted_creds
            existing.credential_type = credential_type
            existing.is_active = True
            db.commit()
            db.refresh(existing)
            return existing
        else:
            # Créer nouveau
            new_credential = UserCredential(
                user_id=user_id,
                service_name=service_name,
                credential_type=credential_type,
                encrypted_credentials=encrypted_creds,
                is_active=True
            )
            db.add(new_credential)
            db.commit()
            db.refresh(new_credential)
            return new_credential

    def get_user_credentials(self, 
                           db: Session, 
                           user_id: int, 
                           service_name: str) -> Optional[Dict[str, Any]]:
        """
        Récupère et déchiffre les credentials utilisateur.
        """
        credential = db.query(UserCredential).filter(
            UserCredential.user_id == user_id,
            UserCredential.service_name == service_name,
            UserCredential.is_active == True
        ).first()

        if credential:
            return self.decrypt_credentials(credential.encrypted_credentials)
        return None

    def get_user_integrations(self, db: Session, user_id: int) -> Dict[str, str]:
        """
        Récupère toutes les intégrations configurées pour un utilisateur.
        """
        credentials = db.query(UserCredential).filter(
            UserCredential.user_id == user_id,
            UserCredential.is_active == True
        ).all()

        return {
            cred.service_name: cred.credential_type 
            for cred in credentials
        }

    def validate_required_credentials(self, 
                                    db: Session, 
                                    user_id: int, 
                                    required_integrations: list) -> Dict[str, bool]:
        """
        Vérifie si l'utilisateur a configuré toutes les intégrations requises.
        """
        user_integrations = self.get_user_integrations(db, user_id)
        
        return {
            integration: integration in user_integrations
            for integration in required_integrations
        }

# Templates de configuration pour les intégrations populaires
INTEGRATION_TEMPLATES = {
    "telegram": {
        "type": "api_key",
        "fields": [
            {"name": "bot_token", "type": "password", "required": True, "description": "Token du bot Telegram"},
            {"name": "chat_id", "type": "text", "required": False, "description": "ID du chat (optionnel)"}
        ],
        "instructions": "1. Créez un bot via @BotFather sur Telegram\n2. Copiez le token fourni\n3. Optionnel: obtenez votre chat_id en envoyant /start au bot"
    },
    "gmail": {
        "type": "oauth",
        "fields": [
            {"name": "client_id", "type": "text", "required": True, "description": "Client ID Google"},
            {"name": "client_secret", "type": "password", "required": True, "description": "Client Secret Google"},
            {"name": "refresh_token", "type": "password", "required": True, "description": "Refresh Token"}
        ],
        "instructions": "1. Créez un projet dans Google Cloud Console\n2. Activez l'API Gmail\n3. Créez des identifiants OAuth 2.0\n4. Autorisez l'application et récupérez le refresh token"
    },
    "slack": {
        "type": "api_key",
        "fields": [
            {"name": "webhook_url", "type": "password", "required": True, "description": "URL du webhook Slack"},
            {"name": "channel", "type": "text", "required": False, "description": "Canal par défaut"}
        ],
        "instructions": "1. Allez dans votre workspace Slack\n2. Créez une nouvelle app\n3. Ajoutez un webhook entrant\n4. Copiez l'URL du webhook"
    },
    "discord": {
        "type": "api_key",
        "fields": [
            {"name": "webhook_url", "type": "password", "required": True, "description": "URL du webhook Discord"},
            {"name": "username", "type": "text", "required": False, "description": "Nom d'utilisateur du bot (optionnel)"}
        ],
        "instructions": "1. Allez dans les paramètres de votre serveur Discord\n2. Intégrations > Webhooks\n3. Créez un nouveau webhook\n4. Copiez l'URL"
    },
    "openai": {
        "type": "api_key",
        "fields": [
            {"name": "api_key", "type": "password", "required": True, "description": "Clé API OpenAI"},
            {"name": "organization", "type": "text", "required": False, "description": "ID de l'organisation (optionnel)"}
        ],
        "instructions": "1. Connectez-vous à platform.openai.com\n2. Allez dans API Keys\n3. Créez une nouvelle clé secrète\n4. Copiez la clé"
    },
    "google_sheets": {
        "type": "service_account",
        "fields": [
            {"name": "service_account_email", "type": "text", "required": True, "description": "Email du compte de service"},
            {"name": "private_key", "type": "textarea", "required": True, "description": "Clé privée du compte de service"}
        ],
        "instructions": "1. Créez un projet dans Google Cloud Console\n2. Activez l'API Google Sheets\n3. Créez un compte de service\n4. Téléchargez le fichier JSON et copiez les valeurs"
    }
}